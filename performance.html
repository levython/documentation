<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Guide | Levython Documentation</title>
    <link rel="icon" href="logo.png">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="sidebar-overlay"></div>
    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="index.html" class="sidebar-logo">
                <img src="logo.png" alt="Levython" class="sidebar-logo-img">
                <span>Levython</span>
            </a>
            <div class="sidebar-version">v1.0.0 Documentation</div>
        </div>

        <div class="sidebar-search">
            <input type="text" placeholder="Search docs..." aria-label="Search documentation">
        </div>

        <nav class="sidebar-nav">
            <div class="nav-section">
                <div class="nav-section-title">Introduction</div>
                <ul class="nav-links">
                    <li><a href="index.html">Index</a></li>
                    <li><a href="about.html">About this documentation</a></li>
                    <li><a href="synopsis.html">Usage and examples</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Getting Started</div>
                <ul class="nav-links">
                    <li><a href="installation.html">Installation</a></li>
                    <li><a href="quickstart.html">Quick Start</a></li>
                    <li><a href="vscode.html">VS Code Extension</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Language Reference</div>
                <ul class="nav-links">
                    <li><a href="variables.html">Variables</a></li>
                    <li><a href="functions.html">Functions</a></li>
                    <li><a href="control-flow.html">Control Flow</a></li>
                    <li><a href="loops.html">Loops</a></li>
                    <li><a href="lists.html">Lists</a></li>
                    <li><a href="strings.html">Strings</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Core Modules</div>
                <ul class="nav-links">
                    <li><a href="io.html">I/O</a></li>
                    <li><a href="file.html">File System</a></li>
                    <li><a href="memory.html">Memory</a></li>
                    <li><a href="bitwise.html">Bitwise</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Advanced</div>
                <ul class="nav-links">
                    <li><a href="performance.html" class="active">Performance</a></li>
                </ul>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Tools</div>
                <ul class="nav-links">
                    <li><a href="cli.html">Command Line</a></li>
                    <li><a href="lpm.html">Package Manager</a></li>
                </ul>
            </div>
        </nav>
    </aside>
    <div class="layout">
        <main class="main">
            <div class="content">
                <div class="breadcrumbs">
                    <a href="index.html">Home</a>
                    <span class="breadcrumb-separator">/</span>
                    <span>Performance Guide</span>
                </div>

                <h1>Performance Optimization</h1>
                <p>Levython is designed for high performance with JIT compilation, optimized memory layout, and zero-overhead abstractions.</p>

                <h2>Benchmarks</h2>
                <p>Performance comparison with other interpreted languages:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Benchmark</th>
                            <th>Levython</th>
                            <th>Python 3.11</th>
                            <th>Node.js 20</th>
                            <th>Ruby 3.2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Fibonacci (n=35)</td>
                            <td><strong>0.45s</strong></td>
                            <td>3.2s</td>
                            <td>0.8s</td>
                            <td>5.1s</td>
                        </tr>
                        <tr>
                            <td>List operations (1M)</td>
                            <td><strong>0.12s</strong></td>
                            <td>0.68s</td>
                            <td>0.25s</td>
                            <td>1.2s</td>
                        </tr>
                        <tr>
                            <td>String concat (100K)</td>
                            <td><strong>0.08s</strong></td>
                            <td>0.45s</td>
                            <td>0.15s</td>
                            <td>0.92s</td>
                        </tr>
                        <tr>
                            <td>Startup time</td>
                            <td><strong>8ms</strong></td>
                            <td>35ms</td>
                            <td>65ms</td>
                            <td>125ms</td>
                        </tr>
                    </tbody>
                </table>

                <h2>JIT Compilation</h2>
                <p>Levython uses Just-In-Time compilation for hot code paths:</p>

                <h3>How JIT Works</h3>
                <ol>
                    <li><strong>Bytecode Interpretation:</strong> Code starts in interpreted mode</li>
                    <li><strong>Hot Path Detection:</strong> Frequently called functions identified</li>
                    <li><strong>Native Compilation:</strong> JIT compiles to x86-64 machine code</li>
                    <li><strong>Execution:</strong> Subsequent calls run native code directly</li>
                </ol>

                <div class="code-block">
                    <pre><code># This function will be JIT compiled after ~100 calls
fun factorial(n)
    if n <= 1 then
        return 1
    end
    return n * factorial(n - 1)
end

# First 100 calls: interpreted (~2.5s total)
# Remaining calls: JIT compiled (~0.3s total)
for i in range(0, 10000) do
    factorial(20)
end</code></pre>
                </div>

                <h2>Optimization Techniques</h2>

                <h3>1. Use Local Variables</h3>
                <p>Local variable access is faster than global lookups:</p>
                <div class="code-block">
                    <pre><code># Slower - global lookup each iteration
for i in range(0, 1000000) do
    result <- math.sqrt(i)
end

# Faster - cache in local variable
sqrt <- math.sqrt
for i in range(0, 1000000) do
    result <- sqrt(i)
end</code></pre>
                </div>

                <h3>2. Avoid Repeated Calculations</h3>
                <div class="code-block">
                    <pre><code># Slower - recalculate every iteration
for i in range(0, len(items)) do
    process(items[i])
end

# Faster - calculate once
n <- len(items)
for i in range(0, n) do
    process(items[i])
end</code></pre>
                </div>

                <h3>3. Use List Comprehensions</h3>
                <div class="code-block">
                    <pre><code># Slower - multiple append operations
result <- []
for i in range(0, 1000) do
    if i % 2 == 0 then
        append(result, i * 2)
    end
end

# Faster - optimized list building
result <- [i * 2 for i in range(0, 1000) if i % 2 == 0]</code></pre>
                </div>

                <h3>4. Preallocate Lists</h3>
                <div class="code-block">
                    <pre><code># Slower - dynamic growth
data <- []
for i in range(0, 10000) do
    append(data, i)
end

# Faster - preallocate with known size
size <- 10000
data <- [0] * size
for i in range(0, size) do
    data[i] <- i
end</code></pre>
                </div>

                <h3>5. String Building</h3>
                <div class="code-block">
                    <pre><code># Slower - creates new string each iteration
result <- ""
for i in range(0, 1000) do
    result <- result + str(i) + ","
end

# Faster - use list and join
parts <- []
for i in range(0, 1000) do
    append(parts, str(i))
end
result <- join(parts, ",")</code></pre>
                </div>

                <h2>Memory Efficiency</h2>

                <h3>NaN-Boxing</h3>
                <p>Levython uses NaN-boxing to store all values in 64 bits:</p>
                <ul>
                    <li><strong>Integers:</strong> 53-bit signed integers stored directly</li>
                    <li><strong>Floats:</strong> Standard IEEE 754 double precision</li>
                    <li><strong>Pointers:</strong> 48-bit pointers in NaN payload</li>
                    <li><strong>Booleans:</strong> Special NaN patterns</li>
                </ul>

                <h3>List Memory Layout</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Memory Complexity</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Create empty list</td>
                            <td>24 bytes</td>
                            <td>Header + small capacity</td>
                        </tr>
                        <tr>
                            <td>Append (within capacity)</td>
                            <td>0 bytes</td>
                            <td>No reallocation</td>
                        </tr>
                        <tr>
                            <td>Append (resize needed)</td>
                            <td>N * 1.5 * 8 bytes</td>
                            <td>Growth factor of 1.5x</td>
                        </tr>
                        <tr>
                            <td>Per element</td>
                            <td>8 bytes</td>
                            <td>NaN-boxed value</td>
                        </tr>
                    </tbody>
                </table>

                <h2>Profiling</h2>
                <p>Measure execution time of code sections:</p>

                <div class="code-block">
                    <pre><code># Time a function
start <- time()
result <- fibonacci(30)
elapsed <- time() - start
say("Execution time: " + str(elapsed) + "s")

# Compare two approaches
start1 <- time()
method1()
time1 <- time() - start1

start2 <- time()
method2()
time2 <- time() - start2

say("Method 1: " + str(time1) + "s")
say("Method 2: " + str(time2) + "s")
say("Speedup: " + str(time1 / time2) + "x")</code></pre>
                </div>

                <h2>Best Practices</h2>
                <ul>
                    <li>✅ Use local variables instead of global lookups</li>
                    <li>✅ Cache function references in loops</li>
                    <li>✅ Preallocate lists with known sizes</li>
                    <li>✅ Use list comprehensions for filtering/mapping</li>
                    <li>✅ Join strings with <code>join()</code> instead of concatenation</li>
                    <li>✅ Avoid unnecessary type conversions</li>
                    <li>✅ Use <code>range()</code> instead of building full lists</li>
                    <li>❌ Don't optimize prematurely - profile first</li>
                    <li>❌ Don't use recursion for deep call stacks (>1000)</li>
                    <li>❌ Don't create temporary lists in hot loops</li>
                </ul>

                <h2>Compiler Optimizations</h2>
                <p>Levython automatically applies these optimizations:</p>

                <h3>Constant Folding</h3>
                <div class="code-block">
                    <pre><code># Input code
x <- 10 * 5 + 3

# Optimized to
x <- 53</code></pre>
                </div>

                <h3>Dead Code Elimination</h3>
                <div class="code-block">
                    <pre><code># Input code
if false then
    say("Never executed")
end

# Optimized to
# (entire block removed)</code></pre>
                </div>

                <h3>Loop Invariant Code Motion</h3>
                <div class="code-block">
                    <pre><code># Input code
for i in range(0, 1000) do
    limit <- len(items) * 2
    process(items[i], limit)
end

# Optimized to
limit <- len(items) * 2
for i in range(0, 1000) do
    process(items[i], limit)
end</code></pre>
                </div>

                <h2>Performance Tips by Use Case</h2>

                <h3>Data Processing</h3>
                <ul>
                    <li>Use list comprehensions for filtering</li>
                    <li>Batch operations instead of processing one at a time</li>
                    <li>Cache computed values in local variables</li>
                </ul>

                <h3>String Manipulation</h3>
                <ul>
                    <li>Use <code>join()</code> for building long strings</li>
                    <li>Cache string functions (upper, lower, trim)</li>
                    <li>Avoid repeated concatenation in loops</li>
                </ul>

                <h3>Numerical Computing</h3>
                <ul>
                    <li>Use integers when possible (faster than floats)</li>
                    <li>Vectorize operations using list comprehensions</li>
                    <li>Minimize function call overhead in tight loops</li>
                </ul>

                <footer class="footer">
                    <p>© 2024 Levython. Released under the MIT License.</p>
                    <p><a href="https://github.com/Levython/Levython">GitHub</a> · <a href="about.html">About</a></p>
                </footer>
            </div>
        </main>
    </div>
    <script src="script.js"></script>
</body>
</html>
